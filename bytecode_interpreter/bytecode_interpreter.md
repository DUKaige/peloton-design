# Bytecode Interpreter

## Overview

The Bytecode Interpreter allows to interpret LLVM IR generated by codegen instead of compiling it. 

## Scope
* All files are in the namespace `peloton::codegen::interpreter`
* `codegen::Query` can decide whether to compile and run the query or to interpret it. 

## Architectural Design

The Bytecode Interpreter consists of three components (BytecodeFunction, BytecodeBuilder and BytecodeInterpreter), which are explained in detail below. 

### 1. BytecodeFunction
Holds all information, that is required to interpret a function, and is completely independent from the CodeContext it was created from (except for tracing information in Debug mode). Once created, it can be executed many times. However, it is not supposed to be saved, but rather to be created on-the-fly before execution. 

It contains:

* The Bytecode itself
* Information needed to create the activation record:
  * Number of value slots to create
  * Number of function arguments (to check if given number is correct)
  * Which constants to initialize
* Call Contexts for external function calls
* Other Bytecode Functions for internal function calls
* In Debug mode: tracing information

All references in the Bytecode Function are done with indexes: 

* Values are referenced with indexes for the value slots
* Instructions are referenced with indexes for the instruction stream

#### Bytecode Internals

All bytecode instructions are defined in `bytecode_definitions.def`. Most instructions are typed and get automatically expanded to their type instances. Typed instructions are accessed by there suffix `<opcode_untyped>_<type>`, e.g. `add_i8`. Type expansion is supported for integer types, floating point types and both. 

Most instructions follow the pattern of having a 2 byte opcode and several 2 byte arguments. Instructions usually fit in a single instruction slot, some instructions however require two or more instruction slots. 

*There is no documentation about the structure of all bytecode instructions. To find out about the arguments of a bytecode instruction, find the corresponding translate function in the BytecodeBuilder and the handler in the BytecodeInterpreter. *

The 2 byte arguments in the bytecode instructions can be one of the following:

1. A value slot index (most arguments in most instructions)
2. A instruction slot index (for branch instruction)
3. An immediate value (only for alloca, gep_offset and extractvalue)

Value Slot zero is a dummy slot. It is used for unused values that have to be put somewhere. This way we avoid handling the cases where wo do not want to use a value. 

### BytecodeBuilder
Creates a BytecodeFunction object from a LLVM function inside a CodeContext, that can be handed to the BytecodeInterpreter. 

`interpreter::BytecodeFunction bytecode = interpreter::BytecodeBuilder::CreateBytecodeFunction(code_context_, query_funcs_.plan_func);`

If the LLVM function can not be translated (because of missing features/types) a `NotSupportedException` is thrown. 

The BytecodeBuilder works in 4 steps:

1. Analysis
2. Register Allocation
3. Translation
4. Finalization

Internal the BytecodeBuilder assigns indexes to LLVM values and instructions, which are usually only accessed by raw pointers. They are used to access those in a continuous way, merge several LLVM values and to compute liveliness. 
Those indexes stay inside the BytecodeBuilder and do not end up in the BytecodeFunction. They are completely independent from the indexes in the BytecodeFunction! 

#### 1. Analysis
Analysis the LLVM function and creates additional information, but doesn't create bytecode. 

* Determining liveness of all LLVM values (definition and last usage)
  * Linear scan algorithm using reverse post order traversal of basic blocks
  * The scheduling of the basic blocks is determined by the reverse post order traversal to make this work
* Merges LLVM values that are equivalent, e.g. when LLVM instructions translate to NOPs
* Merges LLVM constants, which have the same value

#### 2. Register Allocation
Global register allocation: maps every LLVM Value in the LLVM function to a value slot (register). (Naive register allocation can be turned on for debugging purposes)

#### 3. Translation
Translates every LLVM instruction into a bytecode instruction (if not NOP) and places it in the bytecode stream.

As the translation is done in one pass and the instructions can have different size, the destination instruction index for branch instructions is not known when creating the instruction. Therefore these relocations are saved and applied at the end of the pass, when all indexes are known. 

At the end of each basic block, mov instructions are created to resolve the Phi's referencing the basic block. 

Because of the Phi swap problem (lost copy) it can happen, that during translation additional value slots are needed that have not been mapped by the register allocation. The number of additional temporary value slots is tracked and added to the overall number of value slots during finalization. 

#### 4. Finalization
Calculate overall number of required value slots (including the temporary ones added in the translation pass) and prepare the data structures in the Bytecode Function for creating the activation record. 


### BytecodeInterpreter
Takes a Bytecode Function and executes the function it was created for by interpreting the bytecode. 

`return_value = interpreter::BytecodeInterpreter::ExecuteFunction(context, {args, ...});`

For every invocation of a function, a new activation record is created, so recursive calls are actually possible. 


## Debugging
For debugging, the content of a Bytecode Function can be dumped to a file by calling `bytecode.DumpContents()`. 

In log level LOG_TRACE the interpreter will log every single executed instruction and every value assignment. This produces a lot of output! The tracing will become more detailed in future updates. 


## Testing Plan
Most methods in the Bytecode Interpreter and Builder are hard to test, as they require a lot of context. The test cases basically test some edge cases in the Translation/Execution. 


## Trade-offs and Potential Problems
Known limitations:
* LLVM vector types are not supported
* LLVM values are restricted to max. 8 byte
  * Workaround for overflow intrinsics available

*Every query except OrderBy, that is currently created by our test cases, is supported*

## Future Work
* Add functors to allow OrderBy execution
* Add call wrappers for the 20% most called external functions to avoid libffi overhead. 
* Compile queries in background and switch to native execution once the compilation finished. 
* Create LLVM-like execution trace or/and a Debugger interface

## Glossary
RPO
: Reverse Post Order - a way to traverse the control flow graph, needed for linear scanning register allocation

IP
: Instruction Pointer - refers to the interpreter IP (not the actual IP of the processor)
